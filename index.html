<!DOCTYPE html>
<html lang="en">
<head>
   <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-15T6NBG556"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-15T6NBG556');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LUT to CampSnap Filter | Free Online Converter</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="A free, powerful online tool to convert 3D CUBE LUTs (.cube) into the .flt format for CampSnap cameras. Accurate, automatic conversion with live previews.">
    <meta name="keywords" content="CampSnap, CUBE to FLT, LUT converter, .cube, .flt, color grading, filter, CampSnap filter, custom filter, 3D LUT, online converter, free tool, filmmaking, photography, color correction">
    <meta name="author" content="PeterM776">

    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%233b82f6'%3E%3C/rect%3E%3Ccircle cx='50' cy='50' r='30' fill='none' stroke='%23ffffff' stroke-width='8'/%3E%3Ccircle cx='50' cy='50' r='12' fill='%23ffffff'/%3E%3C/svg%3E">

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .btn-glow {
            box-shadow: 0 0 5px rgba(59, 130, 246, 0.5), 0 0 10px rgba(59, 130, 246, 0.3);
            transition: all 0.3s ease;
        }
        .btn-glow:hover, .btn-glow:focus {
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.8), 0 0 20px rgba(59, 130, 246, 0.5);
            transform: translateY(-2px);
        }
        .btn-disabled {
            cursor: not-allowed;
            background-color: #94a3b8;
            box-shadow: none;
        }
        .loader {
            border: 4px solid #e5e7eb;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .file-label {
            border: 2px dashed #d1d5db;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .dark .file-label { border-color: #4b5563; }
        .file-label.dragover {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        .dark .file-label.dragover {
            background-color: #1e293b;
        }
        canvas {
            width: 100%;
            height: auto;
            border-radius: 0.5rem;
            background-color: #f3f4f6;
        }
        .dark canvas {
             background-color: #1f2937;
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 text-gray-800 dark:text-gray-200 flex items-center justify-center min-h-screen p-4 sm:p-6">
  
    <div class="w-full max-w-5xl bg-white dark:bg-gray-800 rounded-2xl shadow-xl p-6 sm:p-8 space-y-8 border border-gray-200 dark:border-gray-700">
        <div class="text-center">
            <h1 class="text-3xl sm:text-4xl font-bold text-gray-900 dark:text-white">LUT to CampSnap Filter</h1>
            <p class="text-gray-500 dark:text-gray-400 mt-2">A powerful, accurate, one-click converter</p>
        </div>

        <!-- How to Use Section -->
        <div class="bg-gray-50 dark:bg-gray-900/50 p-4 rounded-lg border border-gray-200 dark:border-gray-700">
            <h2 class="text-lg font-semibold text-gray-800 dark:text-gray-300 mb-2">How It Works</h2>
            <ol class="list-decimal list-inside text-gray-600 dark:text-gray-400 space-y-1">
                <li>Upload an industry-standard `.cube` file. The tool automatically performs a powerful analysis to create an accurate conversion.</li>
                <li>(Optional) Upload any photo to see a live preview of your original file, the target LUT, and the final `.flt` conversion.</li>
                <li>Click "Download .FLT File" to save your camera-ready filter.</li>
            </ol>
        </div>

        <!-- Inputs Section -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="file-drop-area">
                <label for="cube-file-input" class="file-label relative flex flex-col items-center justify-center w-full h-32 px-4 py-3 bg-white dark:bg-gray-800 rounded-lg cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700">
                    <svg class="w-10 h-10 text-blue-500 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                    <span class="text-gray-600 dark:text-gray-400 font-medium">Select .CUBE File</span>
                    <span id="cube-file-label" class="text-sm text-gray-500">or drag and drop</span>
                </label>
                <input type="file" id="cube-file-input" class="hidden" accept=".cube">
            </div>
            <div class="file-drop-area">
                <label for="image-file-input" class="file-label relative flex flex-col items-center justify-center w-full h-32 px-4 py-3 bg-white dark:bg-gray-800 rounded-lg cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700">
                    <svg class="w-10 h-10 text-blue-500 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"></path></svg>
                    <span class="text-gray-600 dark:text-gray-400 font-medium">Select Preview Image</span>
                     <span id="image-file-label" class="text-sm text-gray-500">or drag and drop</span>
                </label>
                <input type="file" id="image-file-input" class="hidden" accept="image/*">
            </div>
        </div>
        
        <!-- Action Button -->
        <div id="action-area" class="pt-4 text-center hidden">
            <button id="convert-button" class="w-full md:w-1/2 flex items-center justify-center bg-blue-600 text-white font-bold py-3 px-6 rounded-lg btn-glow mx-auto">
                <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                <span id="convert-btn-text">Download .FLT File</span>
            </button>
        </div>
        
        <div id="processing-indicator" class="text-center pt-4 hidden">
             <div class="flex justify-center items-center">
                <div class="loader"></div>
                <p class="ml-4 text-gray-600 dark:text-gray-400">Analyzing CUBE file...</p>
            </div>
        </div>

        <!-- Preview Canvases -->
        <div id="preview-section" class="pt-4 hidden">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div class="text-center">
                    <h3 class="font-semibold mb-2">Original</h3>
                    <canvas id="canvas-original"></canvas>
                </div>
                <div class="text-center">
                    <h3 class="font-semibold mb-2">Target LUT</h3>
                    <canvas id="canvas-lut"></canvas>
                </div>
                <div class="text-center">
                    <h3 class="font-semibold mb-2">Accurate FLT Conversion</h3>
                    <canvas id="canvas-flt"></canvas>
                </div>
            </div>
        </div>

        <!-- Error/Success Messages -->
        <div id="error-box" class="hidden p-4 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-700 rounded-lg">
            <p class="font-bold text-red-800 dark:text-red-300">Error</p>
            <p id="error-message" class="text-sm text-red-700 dark:text-red-400"></p>
        </div>
        
        <footer class="text-center pt-6 border-t border-gray-200 dark:border-gray-700">
            <p class="text-sm text-gray-500">A project by <a href="https://github.com/PeterM776" target="_blank" class="font-medium text-blue-600 hover:underline">PeterM776</a></p>
        </footer>
    </div>

    <script>
        // --- Web Worker Code as a string ---
        const workerCode = `
            const linAlg={multiply:(A,B)=>{const C=Array(A.length).fill(0).map(()=>Array(B[0].length).fill(0));return C.map((r,i)=>r.map((_,j)=>A[i].reduce((s,_,k)=>s+A[i][k]*B[k][j],0)))},transpose:A=>A[0].map((_,c)=>A.map(r=>r[c])),invert:A=>{const d=A[0][0]*(A[1][1]*A[2][2]-A[2][1]*A[1][2])-A[0][1]*(A[1][0]*A[2][2]-A[1][2]*A[2][0])+A[0][2]*(A[1][0]*A[2][1]-A[1][1]*A[2][0]);if(d===0)return null;const i=1/d,C=[[A[1][1]*A[2][2]-A[2][1]*A[1][2],A[0][2]*A[2][1]-A[0][1]*A[2][2],A[0][1]*A[1][2]-A[0][2]*A[1][1]],[A[1][2]*A[2][0]-A[1][0]*A[2][2],A[0][0]*A[2][2]-A[0][2]*A[2][0],A[1][0]*A[0][2]-A[0][0]*A[1][2]],[A[1][0]*A[2][1]-A[2][0]*A[1][1],A[2][0]*A[0][1]-A[0][0]*A[2][1],A[0][0]*A[1][1]-A[1][0]*A[0][1]]];return C.map(r=>r.map(v=>v*i))}};function trilinearInterpolate(r,g,b,lut){const{size,lut3D,domainMin,domainMax}=lut;r=Math.max(0,Math.min(1,(r-domainMin[0])/(domainMax[0]-domainMin[0])));g=Math.max(0,Math.min(1,(g-domainMin[1])/(domainMax[1]-domainMin[1])));b=Math.max(0,Math.min(1,(b-domainMin[2])/(domainMax[2]-domainMin[2])));const x=r*(size-1),y=g*(size-1),z=b*(size-1),x0=Math.floor(x),y0=Math.floor(y),z0=Math.floor(z),x1=Math.min(x0+1,size-1),y1=Math.min(y0+1,size-1),z1=Math.min(z0+1,size-1),xd=x-x0,yd=y-y0,zd=z-z0;const i=(i,j,k)=>lut3D[i+j*size+k*size*size],c000=i(x0,y0,z0),c100=i(x1,y0,z0),c010=i(x0,y1,z0),c110=i(x1,y1,z0),c001=i(x0,y0,z1),c101=i(x1,y0,z1),c011=i(x0,y1,z1),c111=i(x1,y1,z1);const lerp=(a,b,t)=>a*(1-t)+b*t,lerpVector=(v1,v2,t)=>!v1||!v2?[0,0,0]:v1.map((v,i)=>lerp(v,v2[i],t));const c00=lerpVector(c000,c100,xd),c01=lerpVector(c001,c101,xd),c10=lerpVector(c010,c110,xd),c11=lerpVector(c011,c111,xd),c0=lerpVector(c00,c10,yd),c1=lerpVector(c01,c11,yd);return lerpVector(c0,c1,zd)}
            self.onmessage=function(e){const lut=e.data,samples=25,inputs=[],outputs=[];for(let r=0;r<samples;r++)for(let g=0;g<samples;g++)for(let b=0;b<samples;b++){const i=[r/(samples-1),g/(samples-1),b/(samples-1)];inputs.push(i);outputs.push(trilinearInterpolate(i[0],i[1],i[2],lut))}const Y=linAlg.transpose(outputs),X=linAlg.transpose(inputs),Xt=inputs,XtX=linAlg.multiply(X,Xt),XtX_inv=linAlg.invert(XtX);if(!XtX_inv){self.postMessage({error:'Matrix calculation failed. The CUBE may not have enough color data.'});return}const YXt=linAlg.multiply(Y,Xt),M=linAlg.multiply(YXt,XtX_inv),matrixOutputs=linAlg.transpose(linAlg.multiply(M,X));const sums={r:new Array(256).fill(0),g:new Array(256).fill(0),b:new Array(256).fill(0)},counts={r:new Array(256).fill(0),g:new Array(256).fill(0),b:new Array(256).fill(0)};for(let i=0;i<inputs.length;i++){const o=inputs[i],f=outputs[i],m=matrixOutputs[i],r=[f[0]-m[0],f[1]-m[1],f[2]-m[2]];const ri=Math.round(o[0]*255),gi=Math.round(o[1]*255),bi=Math.round(o[2]*255);sums.r[ri]+=o[0]+r[0];counts.r[ri]++;sums.g[gi]+=o[1]+r[1];counts.g[gi]++;sums.b[bi]+=o[2]+r[2];counts.b[bi]++}const curves={r:new Array(256),g:new Array(256),b:new Array(256)};const fillGaps=(c,s,n)=>{for(let i=0;i<256;i++)if(n[i]>0)c[i]=Math.round(Math.max(0,Math.min(1,s[i]/n[i]))*255);let l=-1;for(let i=0;i<256;i++)if(n[i]>0){if(l===-1)for(let j=0;j<i;j++)c[j]=c[i];else for(let j=l+1;j<i;j++)c[j]=Math.round(c[l]+(c[i]-c[l])*(j-l)/(i-l));l=i}if(l!==-1&&l<255)for(let i=l+1;i<256;i++)c[i]=c[l];if(l===-1)for(let i=0;i<256;i++)c[i]=i};fillGaps(curves.r,sums.r,counts.r);fillGaps(curves.g,sums.g,counts.g);fillGaps(curves.b,sums.b,counts.b);self.postMessage({matrix:M.flat().map(v=>Math.round(v*1024)),curves})};
        `;

        // DOM Elements
        const cubeInput = document.getElementById('cube-file-input');
        const imageInput = document.getElementById('image-file-input');
        const cubeLabelSpan = document.querySelector('#cube-file-label span:first-of-type');
        const imageLabelSpan = document.querySelector('#image-file-label span:first-of-type');
        const convertButton = document.getElementById('convert-button');
        const actionArea = document.getElementById('action-area');
        const processingIndicator = document.getElementById('processing-indicator');
        const previewSection = document.getElementById('preview-section');
        const canvasOriginal = document.getElementById('canvas-original');
        const canvasLut = document.getElementById('canvas-lut');
        const canvasFlt = document.getElementById('canvas-flt');
        const errorBox = document.getElementById('error-box');
        const errorMessage = document.getElementById('error-message');

        // State
        let parsedLut = null;
        let originalImage = null;
        let originalFileName = 'converted';
        let generatedFltContent = null;
        let conversionResult = null;
        let analysisWorker;

        // Event Listeners
        cubeInput.addEventListener('change', handleCubeFileSelect);
        imageInput.addEventListener('change', handleImageFileSelect);
        convertButton.addEventListener('click', handleDownload);
        
        // Drag and Drop functionality
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            document.body.addEventListener(eventName, e => e.preventDefault());
        });

        const dropAreas = document.querySelectorAll('.file-drop-area');
        dropAreas.forEach(area => {
            area.addEventListener('dragover', () => area.querySelector('.file-label').classList.add('dragover'));
            area.addEventListener('dragleave', () => area.querySelector('.file-label').classList.remove('dragover'));
            area.addEventListener('drop', e => {
                area.querySelector('.file-label').classList.remove('dragover');
                const dt = e.dataTransfer;
                const files = dt.files;
                if (files.length > 0) {
                    const input = area.querySelector('input[type="file"]');
                    input.files = files;
                    const changeEvent = new Event('change', { bubbles: true });
                    input.dispatchEvent(changeEvent);
                }
            });
        });

        async function handleCubeFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            originalFileName = file.name.replace(/\.cube$/i, '');
            cubeLabelSpan.textContent = file.name;
            const reader = new FileReader();
            reader.onload = async (e) => {
                const cubeFileContent = e.target.result;
                previewSection.classList.add('hidden');
                actionArea.classList.add('hidden');
                processingIndicator.classList.remove('hidden');
                hideError();

                await new Promise(resolve => setTimeout(resolve, 50));

                try {
                    parsedLut = parseCubeFile(cubeFileContent);
                    runAnalysisWorker(parsedLut);
                } catch (err) {
                    showError(err.message);
                    processingIndicator.classList.add('hidden');
                }
            };
            reader.readAsText(file);
        }
        
        function runAnalysisWorker(lutData) {
            if (analysisWorker) analysisWorker.terminate();
            
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            analysisWorker = new Worker(URL.createObjectURL(blob));

            analysisWorker.onmessage = (e) => {
                if(e.data.error) {
                    showError(e.data.error);
                    processingIndicator.classList.add('hidden');
                    return;
                }
                conversionResult = e.data;
                generatedFltContent = formatFltFile(conversionResult.matrix, conversionResult.curves);
                actionArea.classList.remove('hidden');
                if (originalImage) showPreviews();
                processingIndicator.classList.add('hidden');
                analysisWorker.terminate(); 
            };
            
            analysisWorker.onerror = (e) => {
                showError(`Worker error: ${e.message}`);
                processingIndicator.classList.add('hidden');
                analysisWorker.terminate();
            };

            analysisWorker.postMessage(lutData);
        }

        function handleImageFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            imageLabelSpan.textContent = file.name;
            const reader = new FileReader();
            reader.onload = e => {
                originalImage = new Image();
                originalImage.onload = () => { if (conversionResult) showPreviews(); };
                originalImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function showPreviews() {
             if (!originalImage || !conversionResult || !parsedLut) return;
             previewSection.classList.remove('hidden');
             drawOriginalImage();
             applyLutToCanvas();
             applyFltToCanvas(conversionResult.matrix, conversionResult.curves);
        }

        function drawOriginalImage() {
            canvasOriginal.width = originalImage.width;
            canvasOriginal.height = originalImage.height;
            canvasOriginal.getContext('2d').drawImage(originalImage, 0, 0);
        }
        
        function applyLutToCanvas() {
            const ctx = canvasLut.getContext('2d');
            canvasLut.width = originalImage.width;
            canvasLut.height = originalImage.height;
            ctx.drawImage(originalImage, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvasLut.width, canvasLut.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const c = trilinearInterpolate(data[i]/255, data[i+1]/255, data[i+2]/255, parsedLut);
                data[i] = c[0] * 255; data[i+1] = c[1] * 255; data[i+2] = c[2] * 255;
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function applyFltToCanvas(matrix, curves) {
            const ctx = canvasFlt.getContext('2d');
            canvasFlt.width = originalImage.width;
            canvasFlt.height = originalImage.height;
            ctx.drawImage(originalImage, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvasFlt.width, canvasFlt.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const r_in = data[i]/255, g_in = data[i+1]/255, b_in = data[i+2]/255;
                const r_mat = r_in * matrix[0]/1024 + g_in * matrix[1]/1024 + b_in * matrix[2]/1024;
                const g_mat = r_in * matrix[3]/1024 + g_in * matrix[4]/1024 + b_in * matrix[5]/1024;
                const b_mat = r_in * matrix[6]/1024 + g_in * matrix[7]/1024 + b_in * matrix[8]/1024;
                data[i]   = curves.r[Math.round(Math.max(0, Math.min(1, r_mat)) * 255)];
                data[i+1] = curves.g[Math.round(Math.max(0, Math.min(1, g_mat)) * 255)];
                data[i+2] = curves.b[Math.round(Math.max(0, Math.min(1, b_mat)) * 255)];
            }
            ctx.putImageData(imageData, 0, 0);
        }
        
        function formatFltFile(matrix, curves) {
            const fltHeader = 'N, N, 1, 0, N, N, N';
            const fltMatrix = `${matrix[0]}, ${matrix[1]}, ${matrix[2]},\n${matrix[3]}, ${matrix[4]}, ${matrix[5]},\n${matrix[6]}, ${matrix[7]}, ${matrix[8]}`;
            return `${fltHeader}\n${fltMatrix}\n${curves.r.join(', ')}\n${curves.g.join(', ')}\n${curves.b.join(', ')}`;
        }

        function handleDownload() {
            if (!generatedFltContent) { showError("No file has been converted yet."); return; }
            const blob = new Blob([generatedFltContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${originalFileName}.flt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function parseCubeFile(cubeData) {
            const lines = cubeData.split('\n').map(l => l.trim().split('#')[0]);
            let size=0, lut3D=[], domainMin=[0,0,0], domainMax=[1,1,1], dataStarted=false;
            for (const line of lines) {
                if (!line) continue;
                if(dataStarted){
                    const p = line.split(/\s+/).map(Number);
                    if (p.length===3 && !p.some(isNaN)) lut3D.push(p);
                    continue;
                }
                const p = line.split(/\s+/); const key = p[0].toUpperCase();
                if (key === 'LUT_3D_SIZE') size = parseInt(p[1]);
                else if (key === 'DOMAIN_MIN') domainMin = p.slice(1).map(Number);
                else if (key === 'DOMAIN_MAX') domainMax = p.slice(1).map(Number);
                else if (/^[\d.eE+-]/.test(line)){
                    if (size===0) throw new Error("LUT size not defined.");
                    dataStarted = true;
                    const d = line.split(/\s+/).map(Number);
                    if (d.length===3 && !d.some(isNaN)) lut3D.push(d);
                }
            }
            if (size===0 || lut3D.length !== size*size*size) throw new Error('Invalid CUBE file.');
            return { size, lut3D, domainMin, domainMax };
        }
        
        // This function is only used for the preview now. The worker has its own copy.
        function trilinearInterpolate(r, g, b, lut) {
            const { size, lut3D, domainMin, domainMax } = lut;
            r = Math.max(0,Math.min(1,(r-domainMin[0])/(domainMax[0]-domainMin[0])));
            g = Math.max(0,Math.min(1,(g-domainMin[1])/(domainMax[1]-domainMin[1])));
            b = Math.max(0,Math.min(1,(b-domainMin[2])/(domainMax[2]-domainMin[2])));
            const x=r*(size-1), y=g*(size-1), z=b*(size-1);
            const x0=Math.floor(x), y0=Math.floor(y), z0=Math.floor(z);
            const x1=Math.min(x0+1,size-1), y1=Math.min(y0+1,size-1), z1=Math.min(z0+1,size-1);
            const xd=x-x0, yd=y-y0, zd=z-z0;
            const i=(i,j,k)=>lut3D[i+j*size+k*size*size];
            const c000=i(x0,y0,z0), c100=i(x1,y0,z0), c010=i(x0,y1,z0), c110=i(x1,y1,z0);
            const c001=i(x0,y0,z1), c101=i(x1,y0,z1), c011=i(x0,y1,z1), c111=i(x1,y1,z1);
            const lerp=(a,b,t)=>a*(1-t)+b*t;
            const lerpVector=(v1,v2,t)=>!v1||!v2?[0,0,0]:v1.map((v,i)=>lerp(v,v2[i],t));
            const c00=lerpVector(c000,c100,xd), c01=lerpVector(c001,c101,xd);
            const c10=lerpVector(c010,c110,xd), c11=lerpVector(c011,c111,xd);
            const c0=lerpVector(c00,c10,yd), c1=lerpVector(c01,c11,yd);
            return lerpVector(c0, c1, zd);
        }

        function showError(message) { errorMessage.textContent = message; errorBox.classList.remove('hidden'); }
        function hideError() { errorBox.classList.add('hidden'); }
        
    </script>
</body>
</html>
